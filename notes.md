### 1. Recording State Bug
> The audio recorder component has a bug where the recording timer doesn't increment and the recording doesn't automatically stop after reaching the maximum time limit of 10 seconds.

I decided to start with this bug because it's bug #1 and it allows me to understand how recording works (which is the main feature).
How i started:
- I clicked on the "Start Recording" button
- See the issue
- And start digg into the code

Then in the code i found the component and:
- Moved MAX_RECORDING_TIME_SECONDS const out of the component (best practice) and renamed it to mirror time format
- Split max recording behaviour and interval behaviour into two useEffects
- Change max recording time func to setTimeout
- Added a cleanup funcs to clear the interval and timeout (and ref vars to prevent memory leaks)
- Plus changed finalRecordingTime to useMemo to prevent useEffect triggering (maybe just const would be also ok)
- And put media recorder to ref to prevent unnecessary re-renders

In general i decided to keep the code logic the same and do not change it too much.
Plus i saw the issues with startRecording func but decided to dig into it later if i'll have time (still do not know what's next).
Plus i reilized that after recording stopped i do not know whats going on (no feedback) so i decided to fix that next and looks like it's the next task.


### 2. Loading State
> The application currently provides no feedback while audio is being transcribed, which can take a while. Add a loading indicator that:
> - Shows when transcription processing begins
> - Displays while waiting for the transcription result
> - Gracefully transitions when the transcription completes

There is no way to get loading state from AudioRecorder now so it's time to dig into the startRecording func and it's a mess there...

... All test time later ...

Oookey, it was a huge task there and i did a bunch of changes to make everything work. I have no more time to check other tasks but maybe i solved some of them in the process.
So what i did:
- I added tsconfig.json to stop my IDE from yelling at me
- I moved request microphone access and create media recorder to their own functions and moved all of them into AudioRecorderService
- I improved transcribeAudio APIService function and added ability to cancel the request (because it takes a while and user can rerun recording, so we do not want to load our backend)
- Then rewrited all async functions with useEffect (actually i started with that and only after did all other stuff)
- And then i added new props onTranscriptionStart, onTranscriptionCancel, onTranscriptionFailed to AudioRecorder component
- And at the end updated App to handle all of that


--- END OF TIME ---




### 3. Version Compatibility System

In `frontend/services/APIService`, there is a stubbed out version compatibility system. Let's finish implementing it, as well as make some changes to the backend to ensure compatibility:

- Modify the frontend code so that all communication with the backend is handled by APIService
- Add version tracking between frontend and backend
- Implement a mechanism to detect version mismatches
- Prompt users to refresh when the backend version changes
- Gracefully reject requests to the backend when frontend version is stale

### 4. Parallel Processing

Currently, the application can only process one audio transcription at a time. Modify the system to:

- Allow multiple recordings to be processed simultaneously without blocking other api requests
- Show progress/status for each transcription job on the frontend
- Handle errors gracefully

Note: In production, this concurrency would be handled by a more sophisticated system. For this challenge, feel free to use in-memory state storage and simple threading to simulate concurrent processing of jobs. Discuss in your notes what you might do to improve this in a production environment.

### 5. User Identity

We currently have no way to identify users. Add a very simple identity system that:

- Allows users to be identified by a unique id that is generated by the backend
- Stores the user id in local storage on the frontend
- Sends the user id with every request
- Logs the user id with every request

Note: Keep this super simple, and don't worry about things like user authentication or authorization or security.

### 6. Transcription Categorization

It's 2024, and even a simple application like this isn't cool until we sprinkle some AI on it. Add a simple categorization system that:

- Uses the `get_user_model_from_db` function to get the user's preferred LLM provider
- Uses the LLM to categorize the transcription
- Encourages the LLM to return its response in JSON format, and somehow validates that it did so

Note: You can just mock this if don't have access to either of these APIs right now, but we want to see how you approach the prompt engineering and validation, so make sure you mock it robustly. If you do have access and actually implement it, make sure to include documentation of how the API keys should be stored in the .env file.

### 7. Caching

People keep saying the same things, we don't really need to make LLM calls with the same transcripts over and over again. Also, the genius engineers that created the database which takes 8 seconds to return the user's preferred LLM provider are annoyed that we keep calling their expensive function over and over again. Let's cache that too.

Implement a simple in-memory caching system on the backend that saves us money and time.

### 8. Make it pop!

Make the frontend look slightly less ugly.
